From commits at rdiffweb.org  Mon Dec  3 21:38:18 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Mon, 3 Dec 2007 21:38:18 +0100
Subject: [Rdiffweb-commits] r186 - trunk
Message-ID: <200712032038.lB3KcItS000550@sheep.berlios.de>

Author: joshn
Date: 2007-12-03 21:38:00 +0100 (Mon, 03 Dec 2007)
New Revision: 186

Modified:
   trunk/setup.py
Log:
Hardcode location for rdiff-web executable so the init script can find it.

Modified: trunk/setup.py
===================================================================
--- trunk/setup.py	2007-11-30 01:51:18 UTC (rev 185)
+++ trunk/setup.py	2007-12-03 20:38:00 UTC (rev 186)
@@ -16,10 +16,11 @@
       packages=['rdiffWeb'],
       package_data={'rdiffWeb': ['templates/*.html', 'templates/*.xml', 'templates/*.txt', 'static/*.png', 'static/*.js', 'static/*.css', 'static/images/*']},
       data_files=[('/etc/rdiffweb', ['rdw.conf.sample']),
-                  ('/etc/init.d', ['init/rdiff-web'])
+                  ('/etc/init.d', ['init/rdiff-web']),
+                  ('/usr/bin', ['rdiff-web']), # Manually place rdiff-web in /usr/bin, so the init script can find it
                   ],
-      scripts=['rdiff-web', 'rdiff-web-config']
-     )
+      scripts=['rdiff-web-config']
+   )
 else:
    from distutils.dist import Distribution
    import distutils.command.install
@@ -38,6 +39,7 @@
       packages=['rdiffWeb'],
       data_files=[('/etc/rdiffweb', ['rdw.conf.sample']),
                   ('/etc/init.d', ['init/rdiff-web']),
+                  ('/usr/bin', ['rdiff-web']),
                   (packageDataDir+'/templates', glob.glob('rdiffWeb/templates/*.html')),
                   (packageDataDir+'/templates', glob.glob('rdiffWeb/templates/*.xml')),
                   (packageDataDir+'/templates', glob.glob('rdiffWeb/templates/*.txt')),
@@ -46,5 +48,5 @@
                   (packageDataDir+'/static', glob.glob('rdiffWeb/static/*.css')),
                   (packageDataDir+'/static/images', glob.glob('rdiffWeb/static/images/*')),
                   ],
-      scripts=['rdiff-web', 'rdiff-web-config']
-     )
+      scripts=['rdiff-web-config']
+   )



From commits at rdiffweb.org  Wed Dec  5 16:09:56 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Wed, 5 Dec 2007 16:09:56 +0100
Subject: [Rdiffweb-commits] r187 - trunk/rdiffWeb
Message-ID: <200712051509.lB5F9uAI008686@sheep.berlios.de>

Author: joshn
Date: 2007-12-05 16:09:54 +0100 (Wed, 05 Dec 2007)
New Revision: 187

Modified:
   trunk/rdiffWeb/page_status.py
Log:
Remove bogus check for repo in status page

Modified: trunk/rdiffWeb/page_status.py
===================================================================
--- trunk/rdiffWeb/page_status.py	2007-12-03 20:38:00 UTC (rev 186)
+++ trunk/rdiffWeb/page_status.py	2007-12-05 15:09:54 UTC (rev 187)
@@ -23,7 +23,6 @@
          userMessages = self._getUserMessagesForDay(entryTime)
       else:
          # Validate repo parameter
-         if not repo: return self.writeErrorPage("Backup location not specified.")
          if not repo in self.userDB.getUserRepoPaths(self.getUsername()):
             return self.writeErrorPage("Access is denied.")
          try:



From commits at rdiffweb.org  Wed Dec  5 21:51:06 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Wed, 5 Dec 2007 21:51:06 +0100
Subject: [Rdiffweb-commits] r188 - tags
Message-ID: <200712052051.lB5Kp6VA018189@sheep.berlios.de>

Author: joshn
Date: 2007-12-05 21:51:03 +0100 (Wed, 05 Dec 2007)
New Revision: 188

Added:
   tags/release-0.5/
Log:
Tagging version 0.5

Copied: tags/release-0.5 (from rev 187, trunk)



From commits at rdiffweb.org  Mon Dec 17 03:02:00 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Mon, 17 Dec 2007 03:02:00 +0100
Subject: [Rdiffweb-commits] r189 - in trunk: . rdiffWeb
Message-ID: <200712170202.lBH220rJ006581@sheep.berlios.de>

Author: joshn
Date: 2007-12-17 03:01:52 +0100 (Mon, 17 Dec 2007)
New Revision: 189

Modified:
   trunk/rdiff-web
   trunk/rdiffWeb/filter_authentication.py
   trunk/rdiffWeb/page_admin.py
   trunk/rdiffWeb/page_main.py
   trunk/rdiffWeb/page_restore.py
   trunk/rdiffWeb/page_status.py
Log:
Switch from using cherrypy 2.x to cherrypy 3.0. This paves the way for adding SSL support.

Modified: trunk/rdiff-web
===================================================================
--- trunk/rdiff-web	2007-12-05 20:51:03 UTC (rev 188)
+++ trunk/rdiff-web	2007-12-17 02:01:52 UTC (rev 189)
@@ -9,27 +9,23 @@
 import rdiffWeb.email_notification
 import threading
 import rdiffWeb.page_error
+import rdiffWeb.filter_authentication
 
 if __name__ == "__main__":
-   
-   # Initialize config options for static files, so that if we error out, then we can at least display a basic web page.
-   cherrypy.config.update({
-      '/static' : {
-         'staticFilter.on' : True,
-         'staticFilter.root': rdiffWeb.rdw_helpers.getStaticRootPath(),
-         'staticFilter.dir': "static",
-         'rdwAuthenticateFilter.on' : False
-      }
-   })
-   
    # First make sure we have a valid config file.  If not, tell the user to run the config script
    if not rdiffWeb.rdw_config.getConfigFile():
       if os.getuid() != 0:
          error = "<h2>Error: rdiffWeb must be run as root.</h2>"
       else:
          error =  "<h2>Error: rdiffWeb has been installed, but no configuration file exists.<br/>Please run 'rdiff-web-config' to configure settings, then restart rdiffWeb.</h2>"
-      cherrypy.root = rdiffWeb.page_error.rdiffErrorPage(error)
-      cherrypy.server.start()
+      root = rdiffWeb.page_error.rdiffErrorPage(error)
+      cherrypy.quickstart(root, config={
+         '/static' : {
+            'tools.staticdir.on' : True,
+            'tools.staticdir.root': rdiffWeb.rdw_helpers.getStaticRootPath(),
+            'tools.staticdir.dir': "static",
+         }
+      })
       sys.exit(2)
 
 
@@ -70,59 +66,67 @@
    import rdiffWeb.page_status
    import rdiffWeb.page_prefs
 
-   # OK, we're good to go.  Start the server.
-   server = rdiffWeb.page_locations.rdiffLocationsPage()
-
    serverPort = 8080
    if rdiffWeb.rdw_config.getConfigSetting("ServerPort") != "":
       serverPort = int(rdiffWeb.rdw_config.getConfigSetting("ServerPort"))
-   settings = {
-      'sessionFilter.on' : True,
-      'gzipFilter.on': True,
-      'encodingFilter.on' : True,
+   environment = "development"
+   if not debug:
+      environment = "production"
+   global_settings = {
+      'tools.encode.on' : True,
+      'tools.gzip.on': True,
+      'tools.sessions.on' : True,
+      'tools.authenticate.on' : True,
       'autoreload.on' : autoReload,
-      'server.socketHost' : rdiffWeb.rdw_config.getConfigSetting("ServerName"),
-      'server.socketPort' : serverPort,
-      'server.logFile' : logFile,
+      'server.socket_host' : rdiffWeb.rdw_config.getConfigSetting("ServerName"),
+      'server.socket_port' : serverPort,
+      'server.log_file' : logFile,
+      'log.screen': True,
+      'server.environment': environment,
+   }
+   
+   page_settings = {
       '/': {
-         'rdwAuthenticateFilter.on' : True,
-         'rdwAuthenticateFilter.checkLoginAndPassword' : server.checkAuthentication
+         'tools.authenticate.checkAuth' : rdiffWeb.page_locations.rdiffLocationsPage().checkAuthentication,
+         'tools.authenticate.on' : True,
       },
       '/status/feed': {
-         'rdwAuthenticateFilter.method' : 'HTTP Header'
+         'tools.authenticate.authMethod' : 'HTTP Header'
       },
       '/restore': {
-         'encodingFilter.on': False,
+         'tools.encode.on': False,
+      },
+      '/static' : {
+         'tools.staticdir.on' : True,
+         'tools.staticdir.root': rdiffWeb.rdw_helpers.getStaticRootPath(),
+         'tools.staticdir.dir': "static",
+         'tools.authenticate.on' : False,
       }
    }
-   if not debug:
-      settings['server.environment'] = "production"
 
-   if not verbose:
-      settings['server.logToScreen'] = False
-
    if rdiffWeb.rdw_config.getConfigSetting("SessionStorage").lower() == "disk":
       sessionDir = rdiffWeb.rdw_config.getConfigSetting("SessionDir")
       if os.path.exists(sessionDir) and os.path.isdir(sessionDir) and os.access(sessionDir, os.W_OK):
          cherrypy.log("Setting session mode to disk in directory %s" % sessionDir)
-         settings['sessionFilter'] = True
-         settings['sessionFilter.storageType'] = 'File'
-         settings['sessionFilter.storagePath'] = sessionDir
+         global_settings['tools.sessions.on'] = True
+         global_settings['tools.sessions.storage_type'] = 'file'
+         global_settings['tools.sessions.storage_path'] = sessionDir
 
-   cherrypy.config.update(settings)
-   cherrypy.root = rdiffWeb.page_locations.rdiffLocationsPage()
-   cherrypy.root.browse = rdiffWeb.page_browse.rdiffBrowsePage()
-   cherrypy.root.restore = rdiffWeb.page_restore.rdiffRestorePage()
-   cherrypy.root.history = rdiffWeb.page_history.rdiffHistoryPage()
-   cherrypy.root.status = rdiffWeb.page_status.rdiffStatusPage()
-   cherrypy.root.admin = rdiffWeb.page_admin.rdiffAdminPage()
-   cherrypy.root.prefs = rdiffWeb.page_prefs.rdiffPreferencesPage()
+   cherrypy.config.update(global_settings)
+   root = rdiffWeb.page_locations.rdiffLocationsPage()
+   root.browse = rdiffWeb.page_browse.rdiffBrowsePage()
+   root.restore = rdiffWeb.page_restore.rdiffRestorePage()
+   root.history = rdiffWeb.page_history.rdiffHistoryPage()
+   root.status = rdiffWeb.page_status.rdiffStatusPage()
+   root.admin = rdiffWeb.page_admin.rdiffAdminPage()
+   root.prefs = rdiffWeb.page_prefs.rdiffPreferencesPage()
    
    # Start repo spider thread
-   killEvent = threading.Event()
+   if not debug:
+      killEvent = threading.Event()
+   
+      rdiffWeb.rdw_spider_repos.startRepoSpiderThread(killEvent)
+      rdiffWeb.email_notification.startEmailNotificationThread(killEvent)
+      cherrypy.server.on_stop_server_list.append(lambda: killEvent.set())
 
-   rdiffWeb.rdw_spider_repos.startRepoSpiderThread(killEvent)
-   rdiffWeb.email_notification.startEmailNotificationThread(killEvent)
-   cherrypy.server.on_stop_server_list.append(lambda: killEvent.set())
-   
-   cherrypy.server.start()
+   cherrypy.quickstart(root, config=page_settings)

Modified: trunk/rdiffWeb/filter_authentication.py
===================================================================
--- trunk/rdiffWeb/filter_authentication.py	2007-12-05 20:51:03 UTC (rev 188)
+++ trunk/rdiffWeb/filter_authentication.py	2007-12-17 02:01:52 UTC (rev 189)
@@ -1,97 +1,94 @@
 #!/usr/bin/python
 
 import cherrypy
-try:
-   from cherrypy.filters.basefilter import BaseFilter
-except:
-   from cherrypy.lib.filter.basefilter import BaseFilter
 import page_main
 import rdw_helpers
 import base64
 
-class rdwAuthenticationFilter(BaseFilter):
-   loginUrl = "/doLogin"
-   logoutUrl = "/doLogout"
-   sessionUserNameKey = "username"
+_loginUrl = "/login"
+_logoutUrl = "/logout"
+_sessionUserNameKey = "username"
 
-   def beforeMain(self):
-      if not cherrypy.config.get("rdwAuthenticateFilter.on", False):
-         return
-      checkLoginAndPassword = cherrypy.config.get("rdwAuthenticateFilter.checkLoginAndPassword", lambda username, password: u"Invalid username or password")
+def handle_authentication(authMethod='', checkAuth=None):
+   checkLoginAndPassword = checkAuth
+   if not checkLoginAndPassword:
+      checkLoginAndPassword = (lambda username, password: u"Invalid username or password")
 
-      if cherrypy.request.path == self.logoutUrl:
-         cherrypy.session[self.sessionUserNameKey] = None
-         cherrypy.request.user = None
+   if cherrypy.request.path_info == _logoutUrl:
+      cherrypy.session[_sessionUserNameKey] = None
+      cherrypy.request.user = None
+      raise cherrypy.HTTPRedirect("/")
+
+   elif cherrypy.session.get(_sessionUserNameKey):
+      # page passes credentials; allow to be processed
+      if cherrypy.request.path_info == _loginUrl:
          raise cherrypy.HTTPRedirect("/")
+      return False
 
-      elif cherrypy.session.get(self.sessionUserNameKey):
-         # page passes credentials; allow to be processed
-         if cherrypy.request.path == self.loginUrl:
-            raise cherrypy.HTTPRedirect("/")
-         return
+   if authMethod == "HTTP Header":
+      # if not already authenticated, authenticate via the Authorization header
+      httpAuth = _getHTTPAuthorizationCredentials(cherrypy.request.headers.get("Authorization", ""))
+      if httpAuth:
+         error = checkLoginAndPassword(httpAuth["login"], httpAuth["password"])
+         if not error:
+            return False
+      else:
+         error = ""
 
-      if cherrypy.config.get("rdwAuthenticateFilter.method", "") == "HTTP Header":
-         # if not already authenticated, authenticate via the Authorization header
-         httpAuth = self._getHTTPAuthorizationCredentials(cherrypy.request.headerMap.get("Authorization", ""))
-         if httpAuth:
-            error = checkLoginAndPassword(httpAuth["login"], httpAuth["password"])
-            if not error:
-               return
-         else:
-            error = ""
+      cherrypy.response.status = "401 Unauthorized"
+      cherrypy.response.body = "Not Authorized\n" + error
+      cherrypy.response.headers["WWW-Authenticate"] = 'Basic realm="rdiffWeb"'
+      return True
 
-         cherrypy.response.status = "401 Unauthorized"
-         cherrypy.response.body = "Not Authorized\n" + error
-         cherrypy.response.headerMap["WWW-Authenticate"] = 'Basic realm="rdiffWeb"'
-         cherrypy.request.execute_main = False
-         return
+   loginKey = "login"
+   passwordKey = "password"
+   redirectKey = "redirect"
 
-      loginKey = "login"
-      passwordKey = "password"
-      redirectKey = "redirect"
+   loginParms = {"message": "", "action": _loginUrl,
+      "loginKey": loginKey, "passwordKey": passwordKey, "redirectKey": redirectKey,
+      "loginValue": "", "redirectValue": cherrypy.request.path_info + "?" + cherrypy.request.query_string }
 
-      loginParms = {"message": "", "action": self.loginUrl,
-         "loginKey": loginKey, "passwordKey": passwordKey, "redirectKey": redirectKey,
-         "loginValue": "", "redirectValue": cherrypy.request.path + "?" + cherrypy.request.queryString }
+   if cherrypy.request.path_info == _loginUrl and cherrypy.request.method == "POST":
+      # check for login credentials
+      loginValue = cherrypy.request.params[loginKey]
+      passwordValue = cherrypy.request.params[passwordKey]
+      redirectValue = cherrypy.request.params[redirectKey]
+      errorMsg = checkLoginAndPassword(loginValue, passwordValue)
+      if not errorMsg:
+         cherrypy.session[_sessionUserNameKey] = loginValue
+         if not redirectValue:
+            redirectValue = "/"
+         raise cherrypy.HTTPRedirect(redirectValue)
 
-      if cherrypy.request.path == self.loginUrl and cherrypy.request.method == "POST":
-         # check for login credentials
-         loginValue = cherrypy.request.paramMap[loginKey]
-         passwordValue = cherrypy.request.paramMap[passwordKey]
-         redirectValue = cherrypy.request.paramMap[redirectKey]
-         errorMsg = checkLoginAndPassword(loginValue, passwordValue)
-         if not errorMsg:
-            cherrypy.session[self.sessionUserNameKey] = loginValue
-            if not redirectValue:
-               redirectValue = "/"
-            raise cherrypy.HTTPRedirect(redirectValue)
+      # update form values
+      loginParms["message"] = errorMsg
+      loginParms["loginValue"] = loginValue
+      loginParms["redirectValue"] = redirectValue
 
-         # update form values
-         loginParms["message"] = errorMsg
-         loginParms["loginValue"] = loginValue
-         loginParms["redirectValue"] = redirectValue
+   # write login page
+   loginPage = page_main.rdiffPage()
+   cherrypy.response.body = loginPage.compileTemplate("page_start.html", title="Login Required - rdiffWeb", rssLink='', rssTitle='', **loginParms) + loginPage.compileTemplate("login.html", **loginParms)
+   return True
 
-      # write login page
-      loginPage = page_main.rdiffPage()
-      cherrypy.response.body = loginPage.compileTemplate("page_start.html", title="Login Required - rdiffWeb", rssLink='', rssTitle='', **loginParms) + loginPage.compileTemplate("login.html", **loginParms)
-      cherrypy.request.execute_main = False      
+cherrypy.tools.authenticate = cherrypy._cptools.HandlerTool(handle_authentication)
 
-   def _getHTTPAuthorizationCredentials(self, authHeader):
-      try:
-         (realm, authEnc) = authHeader.split()
-      except ValueError:
-         return None
 
-      if realm.lower() == "basic":
-         auth = base64.decodestring(authEnc)
-         colon = auth.find(":")
-         if colon != -1:
-            return { "login": auth[:colon], "password": auth[colon+1:] }
-         else:
-            return { "login": auth, "password": "" }
-
+def _getHTTPAuthorizationCredentials(authHeader):
+   try:
+      (realm, authEnc) = authHeader.split()
+   except ValueError:
       return None
 
+   if realm.lower() == "basic":
+      auth = base64.decodestring(authEnc)
+      colon = auth.find(":")
+      if colon != -1:
+         return { "login": auth[:colon], "password": auth[colon+1:] }
+      else:
+         return { "login": auth, "password": "" }
+
+   return None
+
 ##################### Unit Tests #########################
 
 import unittest, os
@@ -99,10 +96,9 @@
    """Unit tests for the rdwAuthenticationFilter class"""
 
    def testAuthorization(self):
-      filter = rdwAuthenticationFilter()
-      assert not filter._getHTTPAuthorizationCredentials("")
-      assert not filter._getHTTPAuthorizationCredentials("Basic Username Password")
-      assert not filter._getHTTPAuthorizationCredentials("Digest " + base64.encodestring("username"))
-      assert filter._getHTTPAuthorizationCredentials("Basic " + base64.encodestring("username")) == { "login": "username", "password": "" }
-      assert filter._getHTTPAuthorizationCredentials("Basic " + base64.encodestring("user:pass")) == { "login": "user", "password": "pass" }
-      assert filter._getHTTPAuthorizationCredentials("Basic " + base64.encodestring("user:pass:word")) == { "login": "user", "password": "pass:word" }
+      assert not _getHTTPAuthorizationCredentials("")
+      assert not _getHTTPAuthorizationCredentials("Basic Username Password")
+      assert not _getHTTPAuthorizationCredentials("Digest " + base64.encodestring("username"))
+      assert _getHTTPAuthorizationCredentials("Basic " + base64.encodestring("username")) == { "login": "username", "password": "" }
+      assert _getHTTPAuthorizationCredentials("Basic " + base64.encodestring("user:pass")) == { "login": "user", "password": "pass" }
+      assert _getHTTPAuthorizationCredentials("Basic " + base64.encodestring("user:pass:word")) == { "login": "user", "password": "pass:word" }

Modified: trunk/rdiffWeb/page_admin.py
===================================================================
--- trunk/rdiffWeb/page_admin.py	2007-12-05 20:51:03 UTC (rev 188)
+++ trunk/rdiffWeb/page_admin.py	2007-12-17 02:01:52 UTC (rev 189)
@@ -16,11 +16,10 @@
          return self._generatePageHtml("", "")
       
       # We need to change values. Change them, then give back that main page again, with a message
-      print cherrypy.request.paramMap
-      action = cherrypy.request.paramMap["action"]
-      username = cherrypy.request.paramMap["username"]
-      userRoot = cherrypy.request.paramMap["userRoot"]
-      userIsAdmin = cherrypy.request.paramMap.get("isAdmin", False) != False
+      action = cherrypy.request.params["action"]
+      username = cherrypy.request.params["username"]
+      userRoot = cherrypy.request.params["userRoot"]
+      userIsAdmin = cherrypy.request.params.get("isAdmin", False) != False
       
       if action == "edit":
          if not self.userDB.userExists(username):

Modified: trunk/rdiffWeb/page_main.py
===================================================================
--- trunk/rdiffWeb/page_main.py	2007-12-05 20:51:03 UTC (rev 188)
+++ trunk/rdiffWeb/page_main.py	2007-12-17 02:01:52 UTC (rev 189)
@@ -7,19 +7,9 @@
 import rdw_templating
 import rdw_helpers
 import rdw_config
-import filter_https
-import filter_authentication
-import cherrypy.filters.encodingfilter
 
-def getFilters():
-   filters = [filter_authentication.rdwAuthenticationFilter(), cherrypy.filters.encodingfilter.EncodingFilter()]
-   if rdw_config.getConfigSetting("UseHttps").upper() == "TRUE":
-      filters.append(filter_https.rdwHttpsFilter())
-   return filters
-
-
 class rdiffPage:
-   _cpFilterList = getFilters()
+
    def __init__(self):
       self.userDB = db.userDB().getUserDBModule()
 
@@ -70,7 +60,7 @@
          pages.append(("/prefs", "Preferences"))
       if self.userDB.userIsAdmin(self.getUsername()):
          pages.append(("/admin", "Admin"))
-      pages.append(("/doLogout", "Log Out"))
+      pages.append(("/logout", "Log Out"))
       links = []
       for page in pages:
          (url, title) = page

Modified: trunk/rdiffWeb/page_restore.py
===================================================================
--- trunk/rdiffWeb/page_restore.py	2007-12-05 20:51:03 UTC (rev 188)
+++ trunk/rdiffWeb/page_restore.py	2007-12-17 02:01:52 UTC (rev 189)
@@ -1,6 +1,6 @@
 #!/usr/bin/python
 
-from cherrypy.lib.cptools import serveFile
+from cherrypy.lib.static import serve_file
 import rdw_helpers, page_main, librdiff
 import os
 
@@ -43,6 +43,6 @@
       (directory, filename) = os.path.split(filePath)
       file = autoDeleteDir(directory)
       filename = "\""+filename.replace("\"", "\\\"")+"\"" # quote file to handle files with spaces, while escaping quotes in filename
-      return serveFile(filePath, None, disposition="attachment", name=filename)
+      return serve_file(filePath, None, disposition="attachment", name=filename)
    index.exposed = True
 

Modified: trunk/rdiffWeb/page_status.py
===================================================================
--- trunk/rdiffWeb/page_status.py	2007-12-05 20:51:03 UTC (rev 188)
+++ trunk/rdiffWeb/page_status.py	2007-12-17 02:01:52 UTC (rev 189)
@@ -36,7 +36,7 @@
    entry.exposed = True
 
    def feed(self, failures=""):
-      cherrypy.response.headerMap["Content-Type"] = "text/xml"
+      cherrypy.response.headers["Content-Type"] = "text/xml"
       userMessages = self._getRecentUserMessages(failures != "")
       statusUrl = self._buildAbsolutePageUrl(failures != "")
       return self.compileTemplate("status.xml", username=self.getUsername(), link=statusUrl, messages=userMessages)
@@ -96,8 +96,6 @@
       endTime.tzOffset = date.tzOffset
       endTime.setTime(23, 59, 59)
       
-      print startTime.getDisplayString(), endTime.getDisplayString()
-
       return self._getUserMessages(userRepos, True, False, startTime, endTime)
 
    def _getRecentUserMessages(self, failuresOnly):



From commits at rdiffweb.org  Mon Dec 17 03:06:12 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Mon, 17 Dec 2007 03:06:12 +0100
Subject: [Rdiffweb-commits] r190 - trunk
Message-ID: <200712170206.lBH26Cv4006691@sheep.berlios.de>

Author: joshn
Date: 2007-12-17 03:06:05 +0100 (Mon, 17 Dec 2007)
New Revision: 190

Modified:
   trunk/setup.py
Log:
Bump version -- we're now on 0.6, using cherrypy 3.0

Modified: trunk/setup.py
===================================================================
--- trunk/setup.py	2007-12-17 02:01:52 UTC (rev 189)
+++ trunk/setup.py	2007-12-17 02:06:05 UTC (rev 190)
@@ -8,7 +8,7 @@
 pythonVersion = sys.version_info[0]+sys.version_info[1]/10.0
 if pythonVersion > 2.3:
    setup(name='rdiffWeb',
-      version='0.5.0',
+      version='0.6.0',
       description='A web interface to rdiff-backup repositories',
       author='Josh Nisly',
       author_email='rdiffweb at rdiffweb.org',
@@ -31,7 +31,7 @@
    packageDataDir = installer.config_vars['prefix']+"/lib/python"+installer.config_vars['py_version_short']+"/site-packages/rdiffWeb"
 
    setup(name='rdiffWeb',
-      version='0.5.0',
+      version='0.6.0',
       description='A web interface to rdiff-backup repositories',
       author='Josh Nisly',
       author_email='rdiffweb at rdiffweb.org',



From commits at rdiffweb.org  Mon Dec 17 03:07:04 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Mon, 17 Dec 2007 03:07:04 +0100
Subject: [Rdiffweb-commits] r191 - trunk
Message-ID: <200712170207.lBH274ma006755@sheep.berlios.de>

Author: joshn
Date: 2007-12-17 03:06:50 +0100 (Mon, 17 Dec 2007)
New Revision: 191

Modified:
   trunk/rdiff-web
Log:
Reorder imports

Modified: trunk/rdiff-web
===================================================================
--- trunk/rdiff-web	2007-12-17 02:06:05 UTC (rev 190)
+++ trunk/rdiff-web	2007-12-17 02:06:50 UTC (rev 191)
@@ -3,11 +3,12 @@
 import cherrypy
 import getopt
 import os
+import sys
+import threading
+
 import rdiffWeb.rdw_config
-import sys
 import rdiffWeb.rdw_spider_repos
 import rdiffWeb.email_notification
-import threading
 import rdiffWeb.page_error
 import rdiffWeb.filter_authentication
 



From commits at rdiffweb.org  Tue Dec 18 03:14:52 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Tue, 18 Dec 2007 03:14:52 +0100
Subject: [Rdiffweb-commits] r192 - trunk
Message-ID: <200712180214.lBI2EqbS008566@sheep.berlios.de>

Author: joshn
Date: 2007-12-18 03:14:48 +0100 (Tue, 18 Dec 2007)
New Revision: 192

Modified:
   trunk/rdiff-web
Log:
Add config option to enable SSL support

Modified: trunk/rdiff-web
===================================================================
--- trunk/rdiff-web	2007-12-17 02:06:50 UTC (rev 191)
+++ trunk/rdiff-web	2007-12-18 02:14:48 UTC (rev 192)
@@ -82,6 +82,8 @@
       'server.socket_host' : rdiffWeb.rdw_config.getConfigSetting("ServerName"),
       'server.socket_port' : serverPort,
       'server.log_file' : logFile,
+      'server.ssl_certificate': rdiffWeb.rdw_config.getConfigSetting("SslCertificate"),
+      'server.ssl_private_key': rdiffWeb.rdw_config.getConfigSetting("SslPrivateKey"),
       'log.screen': True,
       'server.environment': environment,
    }



From commits at rdiffweb.org  Thu Dec 27 18:15:43 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Thu, 27 Dec 2007 18:15:43 +0100
Subject: [Rdiffweb-commits] r193 - trunk/rdiffWeb
Message-ID: <200712271715.lBRHFh7W003778@sheep.berlios.de>

Author: joshn
Date: 2007-12-27 18:15:36 +0100 (Thu, 27 Dec 2007)
New Revision: 193

Modified:
   trunk/rdiffWeb/page_admin.py
   trunk/rdiffWeb/page_browse.py
   trunk/rdiffWeb/page_history.py
   trunk/rdiffWeb/page_main.py
   trunk/rdiffWeb/page_prefs.py
   trunk/rdiffWeb/page_restore.py
   trunk/rdiffWeb/page_status.py
Log:
Start wrapping database object. This will let us use thread-specific db ojects.


Modified: trunk/rdiffWeb/page_admin.py
===================================================================
--- trunk/rdiffWeb/page_admin.py	2007-12-18 02:14:48 UTC (rev 192)
+++ trunk/rdiffWeb/page_admin.py	2007-12-27 17:15:36 UTC (rev 193)
@@ -22,18 +22,18 @@
       userIsAdmin = cherrypy.request.params.get("isAdmin", False) != False
       
       if action == "edit":
-         if not self.userDB.userExists(username):
+         if not self.getUserDB().userExists(username):
             return self._generatePageHtml("", "The user does not exist.")
          
-         self.userDB.setUserInfo(username, userRoot, userIsAdmin)
+         self.getUserDB().setUserInfo(username, userRoot, userIsAdmin)
          return self._generatePageHtml("User information modified successfully", "")
       elif action == "add":
-         if self.userDB.userExists(username):
+         if self.getUserDB().userExists(username):
             return self._generatePageHtml("", "The specified user already exists.", username, userRoot, userIsAdmin)
          if username == "":
             return self._generatePageHtml("", "The username is invalid.", username, userRoot, userIsAdmin)
-         self.userDB.addUser(username)
-         self.userDB.setUserInfo(username, userRoot, userIsAdmin)
+         self.getUserDB().addUser(username)
+         self.getUserDB().setUserInfo(username, userRoot, userIsAdmin)
          return self._generatePageHtml("User added successfully.", "")
       
    index.exposed = True
@@ -41,26 +41,26 @@
    def deleteUser(self, user):
       if not self._userIsAdmin(): return self.writeErrorPage("Access denied.")
 
-      if not self.userDB.userExists(user):
+      if not self.getUserDB().userExists(user):
          return self._generatePageHtml("", "The user does not exist.")
 
       if user == self.getUsername():
          return self._generatePageHtml("", "You cannot remove your own account!.")
 
-      self.userDB.deleteUser(user)
+      self.getUserDB().deleteUser(user)
       return self._generatePageHtml("User account removed.", "")
    deleteUser.exposed = True
 
    ############### HELPER FUNCTIONS #####################
    def _userIsAdmin(self):
-      return self.userDB.userIsAdmin(self.getUsername())
+      return self.getUserDB().userIsAdmin(self.getUsername())
 
    def _isSubmit(self):
       return cherrypy.request.method == "POST"
 
    def _generatePageHtml(self, message, error, username="", userRoot="", isAdmin=False):
-      userNames = self.userDB.getUserList()
-      users = [ { "username" : user, "isAdmin" : self.userDB.userIsAdmin(user), "userRoot" : self.userDB.getUserRoot(user) } for user in userNames ]
+      userNames = self.getUserDB().getUserList()
+      users = [ { "username" : user, "isAdmin" : self.getUserDB().userIsAdmin(user), "userRoot" : self.getUserDB().getUserRoot(user) } for user in userNames ]
       parms = { "users" : users, 
                 "username" : username, 
                 "userRoot" : userRoot, 

Modified: trunk/rdiffWeb/page_browse.py
===================================================================
--- trunk/rdiffWeb/page_browse.py	2007-12-18 02:14:48 UTC (rev 192)
+++ trunk/rdiffWeb/page_browse.py	2007-12-27 17:15:36 UTC (rev 193)
@@ -16,11 +16,11 @@
 
       # NOTE: a blank path parm is allowed, since that just results in a listing of the repo root
       if not repo: return self.writeErrorPage("Backup location not specified.")
-      if not repo in self.userDB.getUserRepoPaths(self.getUsername()):
+      if not repo in self.getUserDB().getUserRepoPaths(self.getUsername()):
          return self.writeErrorPage("Access is denied.")
 
       try:
-         parms = self.getParmsForPage(self.userDB.getUserRoot(self.getUsername()), repo, path, restore)
+         parms = self.getParmsForPage(self.getUserDB().getUserRoot(self.getUsername()), repo, path, restore)
       except librdiff.FileError, error:
          return self.writeErrorPage(str(error))
       page = self.startPage(parms["title"])

Modified: trunk/rdiffWeb/page_history.py
===================================================================
--- trunk/rdiffWeb/page_history.py	2007-12-18 02:14:48 UTC (rev 192)
+++ trunk/rdiffWeb/page_history.py	2007-12-27 17:15:36 UTC (rev 193)
@@ -13,12 +13,12 @@
          return self.writeErrorPage(str(error))
 
       if not repo: return self.writeErrorPage("Backup location not specified.")
-      if not repo in self.userDB.getUserRepoPaths(self.getUsername()):
+      if not repo in self.getUserDB().getUserRepoPaths(self.getUsername()):
          return self.writeErrorPage("Access is denied.")
 
       parms = {}
       try:
-         parms = self.getParmsForPage(joinPaths(self.userDB.getUserRoot(self.getUsername()), repo), repo)
+         parms = self.getParmsForPage(joinPaths(self.getUserDB().getUserRoot(self.getUsername()), repo), repo)
       except librdiff.FileError, error:
          return self.writeErrorPage(error.getErrorString())
       

Modified: trunk/rdiffWeb/page_main.py
===================================================================
--- trunk/rdiffWeb/page_main.py	2007-12-18 02:14:48 UTC (rev 192)
+++ trunk/rdiffWeb/page_main.py	2007-12-27 17:15:36 UTC (rev 193)
@@ -10,9 +10,6 @@
 
 class rdiffPage:
 
-   def __init__(self):
-      self.userDB = db.userDB().getUserDBModule()
-
    ############################## HELPER FUNCTIONS ###################################
    def buildBrowseUrl(self, repo, path, isRestoreView):
       url = "/browse/?repo="+rdw_helpers.encodeUrl(repo, "/")+"&path="+rdw_helpers.encodeUrl(path, "/")
@@ -34,7 +31,7 @@
          
    def validateUserPath(self, path):
       '''Takes a path relative to the user's root dir and validates that it is valid and within the user's root'''
-      path = rdw_helpers.joinPaths(self.userDB.getUserRoot(self.getUsername()), path)
+      path = rdw_helpers.joinPaths(self.getUserDB().getUserRoot(self.getUsername()), path)
       path = path.rstrip("/")
       realPath = os.path.realpath(path)
       if realPath != path:
@@ -43,8 +40,14 @@
       # Make sure that the path starts with the user root
       # This check should be accomplished by ensurePathValid, but adding for a sanity check
       realDestPath = os.path.realpath(path)
-      if realDestPath.find(self.userDB.getUserRoot(self.getUsername())) != 0:      
+      if realDestPath.find(self.getUserDB().getUserRoot(self.getUsername())) != 0:      
          raise rdw_helpers.accessDeniedError
+      
+      
+   def getUserDB(self):
+      if not hasattr(cherrypy.thread_data, 'db'):
+         cherrypy.thread_data.db = db.userDB().getUserDBModule()
+      return cherrypy.thread_data.db
 
 
    ########################## PAGE HELPER FUNCTIONS ##################################
@@ -56,9 +59,9 @@
 
    def writeTopLinks(self):
       pages = [("/status/", "Backup Status")]
-      if self.userDB.modificationsSupported():
+      if self.getUserDB().modificationsSupported():
          pages.append(("/prefs", "Preferences"))
-      if self.userDB.userIsAdmin(self.getUsername()):
+      if self.getUserDB().userIsAdmin(self.getUsername()):
          pages.append(("/admin", "Admin"))
       pages.append(("/logout", "Log Out"))
       links = []
@@ -82,7 +85,7 @@
 
    ########## SESSION INFORMATION #############
    def checkAuthentication(self, username, password):
-      if self.userDB.areUserCredentialsValid(username, password):
+      if self.getUserDB().areUserCredentialsValid(username, password):
          cherrypy.session['username'] = username
          return None
       return "Invalid username or password."

Modified: trunk/rdiffWeb/page_prefs.py
===================================================================
--- trunk/rdiffWeb/page_prefs.py	2007-12-18 02:14:48 UTC (rev 192)
+++ trunk/rdiffWeb/page_prefs.py	2007-12-27 17:15:36 UTC (rev 193)
@@ -30,16 +30,16 @@
    index.exposed = True
    
    def _changePassword(self, currentPassword, newPassword, confirmPassword):
-      if not self.userDB.modificationsSupported():
+      if not self.getUserDB().modificationsSupported():
          return self._getPrefsPage(errorMessage="Password changing is not supported with the active user database.")
       
-      if not self.userDB.areUserCredentialsValid(self.getUsername(), currentPassword):
+      if not self.getUserDB().areUserCredentialsValid(self.getUsername(), currentPassword):
          return self._getPrefsPage(errorMessage="The 'Current Password' is invalid.")
       
       if newPassword != confirmPassword:
          return self._getPrefsPage(errorMessage="The passwords do not match.")
 
-      self.userDB.setUserPassword(self.getUsername(), newPassword)      
+      self.getUserDB().setUserPassword(self.getUsername(), newPassword)      
       return self._getPrefsPage(statusMessage="Password updated successfully.")
    
    def _updateRepos(self):
@@ -47,16 +47,16 @@
       return self._getPrefsPage(statusMessage="Successfully updated backup locations.")
 
    def _setNotifications(self, parms):
-      if not self.userDB.modificationsSupported():
+      if not self.getUserDB().modificationsSupported():
          return self._getPrefsPage(errorMessage="Email notification is not supported with the active user database.")
       
-      repos = self.userDB.getUserRepoPaths(self.getUsername())
+      repos = self.getUserDB().getUserRepoPaths(self.getUsername())
       
       for parmName in parms.keys():
          if parmName == "userEmail":
             if parms[parmName] == self.sampleEmail:
                parms[parmName] = ''
-            self.userDB.setUserEmail(self.getUsername(), parms[parmName])
+            self.getUserDB().setUserEmail(self.getUsername(), parms[parmName])
          if parmName.endswith("numDays"):
             backupName = parmName[:-7]
             if backupName in repos:
@@ -64,23 +64,23 @@
                   maxDays = 0
                else:
                   maxDays = int(parms[parmName][0])
-               self.userDB.setRepoMaxAge(self.getUsername(), backupName, maxDays)
+               self.getUserDB().setRepoMaxAge(self.getUsername(), backupName, maxDays)
                
       return self._getPrefsPage(statusMessage="Successfully changed notification settings.")
    
    def _setRestoreType(self, restoreType):
-      if not self.userDB.modificationsSupported():
+      if not self.getUserDB().modificationsSupported():
          return self.getPrefsPage(errorMessage="Setting the restore format is not supported with the active user database.")
       
       if restoreType == 'zip' or restoreType == 'tgz':
-         self.userDB.setUseZipFormat(self.getUsername(), restoreType == 'zip')
+         self.getUserDB().setUseZipFormat(self.getUsername(), restoreType == 'zip')
       else:
          return self._getPrefsPage(errorMessage='Invalid restore format.')
       return self._getPrefsPage(statusMessage="Successfully set restore format.")
    
    def _getPrefsPage(self, errorMessage="", statusMessage=""):
       title = "User Preferences"
-      email = self.userDB.getUserEmail(self.getUsername());
+      email = self.getUserDB().getUserEmail(self.getUsername());
       parms = {
          "title" : title,
          "error" : errorMessage,
@@ -88,14 +88,14 @@
          "userEmail" : email,
          "notificationsEnabled" : False,
          "backups" : [],
-         "useZipFormat": self.userDB.useZipFormat(self.getUsername()),
+         "useZipFormat": self.getUserDB().useZipFormat(self.getUsername()),
          "sampleEmail": self.sampleEmail
       }
       if email_notification.emailNotifier().notificationsEnabled():
-         repos = self.userDB.getUserRepoPaths(self.getUsername())
+         repos = self.getUserDB().getUserRepoPaths(self.getUsername())
          backups = []
          for repo in repos:
-            maxAge = self.userDB.getRepoMaxAge(self.getUsername(), repo)
+            maxAge = self.getUserDB().getRepoMaxAge(self.getUsername(), repo)
             notifyOptions = []
             for i in range(0, 8):
                notifyStr = "Don't notify"

Modified: trunk/rdiffWeb/page_restore.py
===================================================================
--- trunk/rdiffWeb/page_restore.py	2007-12-18 02:14:48 UTC (rev 192)
+++ trunk/rdiffWeb/page_restore.py	2007-12-27 17:15:36 UTC (rev 193)
@@ -19,10 +19,10 @@
       except rdw_helpers.accessDeniedError, error:
          return self.writeErrorPage(str(error))
       if not repo: return self.writeErrorPage("Backup location not specified.")
-      if not repo in self.userDB.getUserRepoPaths(self.getUsername()):
+      if not repo in self.getUserDB().getUserRepoPaths(self.getUsername()):
          return self.writeErrorPage("Access is denied.")
 
-      if librdiff.backupIsInProgressForRepo(rdw_helpers.joinPaths(self.userDB.getUserRoot(self.getUsername()), repo)):
+      if librdiff.backupIsInProgressForRepo(rdw_helpers.joinPaths(self.getUserDB().getUserRoot(self.getUsername()), repo)):
          return self.writeErrorPage("A backup is currently in progress to this location.  Restores are disabled until this backup is complete.")
 
       try:
@@ -32,8 +32,8 @@
          if not file:
             file = path
             path = "/"
-         fullPath = rdw_helpers.joinPaths(self.userDB.getUserRoot(self.getUsername()), repo)
-         useZipFormat = self.userDB.useZipFormat(self.getUsername())
+         fullPath = rdw_helpers.joinPaths(self.getUserDB().getUserRoot(self.getUsername()), repo)
+         useZipFormat = self.getUserDB().useZipFormat(self.getUsername())
          filePath = librdiff.restoreFileOrDir(fullPath, path, file, restoreTime, useZipFormat)
       except librdiff.FileError, error:
          return self.writeErrorPage(error.getErrorString())

Modified: trunk/rdiffWeb/page_status.py
===================================================================
--- trunk/rdiffWeb/page_status.py	2007-12-18 02:14:48 UTC (rev 192)
+++ trunk/rdiffWeb/page_status.py	2007-12-27 17:15:36 UTC (rev 193)
@@ -23,7 +23,7 @@
          userMessages = self._getUserMessagesForDay(entryTime)
       else:
          # Validate repo parameter
-         if not repo in self.userDB.getUserRepoPaths(self.getUsername()):
+         if not repo in self.getUserDB().getUserRepoPaths(self.getUsername()):
             return self.writeErrorPage("Access is denied.")
          try:
             self.validateUserPath(repo)
@@ -83,7 +83,7 @@
       return self._buildAbsolutePageUrl(False) + "entry?repo="+rdw_helpers.encodeUrl(repo)+"&date="+rdw_helpers.encodeUrl(date.getUrlString())
    
    def _getUserMessagesForDay(self, date):
-      userRepos = self.userDB.getUserRepoPaths(self.getUsername())
+      userRepos = self.getUserDB().getUserRepoPaths(self.getUsername())
 
       # Set the start and end time to be the start and end of the day, respectively, to get all entries for that day
       startTime = rdw_helpers.rdwTime()
@@ -99,14 +99,14 @@
       return self._getUserMessages(userRepos, True, False, startTime, endTime)
 
    def _getRecentUserMessages(self, failuresOnly):
-      userRepos = self.userDB.getUserRepoPaths(self.getUsername())
+      userRepos = self.getUserDB().getUserRepoPaths(self.getUsername())
       asOfDate = rdw_helpers.rdwTime()
       asOfDate.initFromMidnightUTC(-5)
 
       return self._getUserMessages(userRepos, not failuresOnly, True, asOfDate, None)
 
    def _getUserMessages(self, repos, includeSuccess, includeFailure, earliestDate, latestDate):
-      userRoot = self.userDB.getUserRoot(self.getUsername())
+      userRoot = self.getUserDB().getUserRoot(self.getUsername())
 
       repoErrors = []
       allBackups = []



From commits at rdiffweb.org  Thu Dec 27 18:16:30 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Thu, 27 Dec 2007 18:16:30 +0100
Subject: [Rdiffweb-commits] r194 - trunk/rdiffWeb
Message-ID: <200712271716.lBRHGUZq003881@sheep.berlios.de>

Author: joshn
Date: 2007-12-27 18:16:26 +0100 (Thu, 27 Dec 2007)
New Revision: 194

Modified:
   trunk/rdiffWeb/page_locations.py
Log:
Commit file missed in last commit.

Modified: trunk/rdiffWeb/page_locations.py
===================================================================
--- trunk/rdiffWeb/page_locations.py	2007-12-27 17:15:36 UTC (rev 193)
+++ trunk/rdiffWeb/page_locations.py	2007-12-27 17:16:26 UTC (rev 194)
@@ -8,7 +8,7 @@
    backup directories. This is the root (/) page '''
    def index(self):
       page = self.startPage("Backup Locations")
-      page = page + self.compileTemplate("repo_listing.html", **self.getParmsForPage(self.userDB.getUserRoot(self.getUsername()), self.userDB.getUserRepoPaths(self.getUsername())))
+      page = page + self.compileTemplate("repo_listing.html", **self.getParmsForPage(self.getUserDB().getUserRoot(self.getUsername()), self.getUserDB().getUserRepoPaths(self.getUsername())))
       page = page + self.endPage()
       return page
    index.exposed = True



From commits at rdiffweb.org  Thu Dec 27 18:18:22 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Thu, 27 Dec 2007 18:18:22 +0100
Subject: [Rdiffweb-commits] r195 - in trunk: . rdiffWeb
Message-ID: <200712271718.lBRHIMJa004014@sheep.berlios.de>

Author: joshn
Date: 2007-12-27 18:18:16 +0100 (Thu, 27 Dec 2007)
New Revision: 195

Added:
   trunk/rdiffWeb/db_sqlite.py
Modified:
   trunk/rdiff-web-config
   trunk/rdiffWeb/db.py
   trunk/rdiffWeb/rdw_config.py
Log:
Implement new sqlite database backend.


Modified: trunk/rdiff-web-config
===================================================================
--- trunk/rdiff-web-config	2007-12-27 17:16:26 UTC (rev 194)
+++ trunk/rdiff-web-config	2007-12-27 17:18:16 UTC (rev 195)
@@ -4,7 +4,7 @@
 import sys
 import stat
 import rdiffWeb.rdw_config
-import rdiffWeb.db_mysql
+import rdiffWeb.db_sqlite
 import rdiffWeb.rdw_spider_repos
 
 # legalOptions should be a list of legal values.  An empty list means all values are legal
@@ -35,131 +35,28 @@
    open(configFilePath, "a").write(lineText+"\n")
    os.chmod(configFilePath, stat.S_IRWXU)
 
-def fileSetup():
-   print "File backend chosen.\n"
-   #TODO: load default answers from existing config file, if any
-   if os.access("/etc/rdiffweb/rdw.conf", os.F_OK):
-      os.unlink("/etc/rdiffweb/rdw.conf")
-   addConfigFileLine("UserDB=File")
-   print "A username and password will be required to log in."
-   username = promptUser("Enter the username", [], "", False)
-   addConfigFileLine("Username="+username)
-   password = promptUser("Enter the password", [], "", False)
-   addConfigFileLine("Password="+password)
-   addConfigFileLine("UserRoot=/") # For the file backend, just sent the user root to "/"; it's too confusing to try to explain
-
-   repositories = []
-   newRepo = ""
-   print "Finally, backup locations must be entered.  A backup location is the path to an rdiff-backup repository. \
-For example: /var/backups/nightly or /home/bill/backup.  Multiple backup locations may be entered.  Enter only \
-one backup location at a time; I will continue to prompt for more backup locations until a blank location is entered."
-   while not repositories or newRepo:
-      newRepo = promptUser("Enter backup location", [], "", False)
-      if not newRepo:
-         if not repositories:
-            print "At least one backup location must be entered."
-      else:
-         if not os.access(newRepo, os.F_OK):
-            response = promptUser("The backup location entered does not exist.  Are you sure you want to add it?", ["yes", "no"], "no", False)
-            if response == "no":
-               continue
-
-         repositories.append(newRepo)
-   reposString = "|".join(repositories)
-   addConfigFileLine("UserRepoPaths="+reposString)
-
-def executeQuery(sqlConnection, query, *args):
-   cursor = sqlConnection.cursor()
-   cursor.execute(query, *args)
-   results = cursor.fetchall()
-   return results
-
-def listDatabases(sqlConnection):
-   results = executeQuery(sqlConnection, "show databases")
-   databases = [ x[0] for x in results]
-   return databases
-
 def addUser(username, password, userRoot, isAdmin):
-   mysqlUserDb = rdiffWeb.db_mysql.mysqlUserDB()
-   mysqlUserDb.addUser(username)
-   mysqlUserDb.setUserPassword(username, password)
-   mysqlUserDb.setUserInfo(username, userRoot, isAdmin)
+   userDB = rdiffWeb.db_sqlite.sqliteUserDB(rdiffWeb.rdw_config.getDatabasePath())
+   userDB.addUser(username)
+   userDB.setUserPassword(username, password)
+   userDB.setUserInfo(username, userRoot, isAdmin)
 
-def mysqlSetup():
-   print "MySQL backend chosen.\n"
+def sqlSetup():
    # TODO: load default answers from existing config file, if any
    try:
-      import MySQLdb
+      import sqlite3
    except ImportError:
-      print "Unable to load MySQLdb module.  Please install this module and try again."
+      print "Unable to load the python bindings for sqlite (sometimes packaged as python-sqlite).  Please install this module and try again."
       sys.exit(2)
 
-   sqlHost = "localhost"
-   sqlUser = ""
-   sqlPassword = ""
-   sqlDatabase = ""
-   if os.access("/etc/rdiffweb/rdw.conf", os.F_OK):
-      try:
-         sqlHost = rdiffWeb.rdw_config.getConfigSetting("sqlHost")
-         sqlUser = rdiffWeb.rdw_config.getConfigSetting("sqlUsername")
-         sqlPassword = rdiffWeb.rdw_config.getConfigSetting("sqlPassword")
-      except rdiffWeb.rdw_config.SettingsError:
-         pass
-      os.unlink("/etc/rdiffweb/rdw.conf")
-   addConfigFileLine("UserDB=MySQL")
-   print "First, a connection to the MySQL server must be specified.  This includes host, username and password."
+   userDB = rdiffWeb.db_sqlite.sqliteUserDB(rdiffWeb.rdw_config.getDatabasePath())
 
-   import MySQLdb
-   sqlConnection = None
-   while not sqlConnection:
-      sqlHost = promptUser("Enter the sql hostname", [], sqlHost, False)
-      sqlUser = promptUser("Enter the username", [], sqlUser, False)
-      sqlPassword = promptUser("Enter the password", [], sqlPassword, False)
-
-      # We try to connect to the database specified.  Catch the most common errors, and just
-      # let the rest crash out.  The user will have to fix the less common ones on their own.
-      try:
-         sqlConnection = MySQLdb.connect(host=sqlHost, user=sqlUser, passwd=sqlPassword)
-      except MySQLdb.OperationalError, error:
-         if error[0] == 2002:
-            print "It appears that MySQL is not running on the specified host. Please try again."
-            continue
-         if error[0] == 1045:
-            print "Authentication failed using the specified username/password. Please try again."
-            continue
-         raise error
-
-   addConfigFileLine("sqlHost="+sqlHost)
-   addConfigFileLine("sqlUsername="+sqlUser)
-   addConfigFileLine("sqlPassword="+sqlPassword)
-
-   while not sqlDatabase or sqlDatabase in listDatabases(sqlConnection):
-      if not sqlDatabase:
-         sqlDatabase = promptUser("Enter the name of the database", [], "rdiffweb", False)
-      else:
-         userPrompt = "The database '%s' already exists.  If you to continue, the database will be deleted and recreated, losing all data.  If you do not continue, you will be prompted for another database name.  Do you want to continue?" % sqlDatabase
-         response = promptUser(userPrompt, ["yes", "no"], "no", False)
-         if response == "yes":
-            executeQuery(sqlConnection, "drop database "+sqlDatabase)
-         else:
-            sqlDatabase = ""
-
-   executeQuery(sqlConnection, "create database "+sqlDatabase)
-   executeQuery(sqlConnection, "use "+sqlDatabase)
-
-   addConfigFileLine("sqlDatabase="+sqlDatabase)
-
-   mysqlUserDb = rdiffWeb.db_mysql.mysqlUserDB()
-   for createStatement in mysqlUserDb._getCreateStatements():
-      executeQuery(sqlConnection, createStatement)
-
-   mysqlUserDb = rdiffWeb.db_mysql.mysqlUserDB()
-
-   print "\nYou must now add the first user account.  This user will have admin privileges, and therefore will have the ability to add/delete other users."
+   print "\nLet's add the first user account.  This user will have admin privileges, including the ability to add/delete other users."
    username = promptUser("Enter the username", [], "", False)
    password = promptUser("Enter the password", [], "", False)
-   mysqlUserDb.addUser(username)
-   mysqlUserDb.setUserPassword(username, password)
+   userDB._executeQuery("BEGIN")
+   userDB.addUser(username)
+   userDB.setUserPassword(username, password)
    print "\nEach user has a user root directory.  This root directory acts much as the system root directory.  All backup repositories must be within this directory.\nExamples: /var/backup/repos"
    userRoot = ""
    while True:
@@ -168,40 +65,31 @@
          if promptUser("The entered directory does not exist.  Do you want to continue?", ["yes", "no"], "no", False) == "yes":
             break
       break
-   mysqlUserDb.setUserInfo(username, userRoot, True)
+   userDB.setUserInfo(username, userRoot, True)
    print "User added successfully."
 
    prompt = "\nDo you want me to automatically search the user's root directory for backup repositories?"
    response = promptUser(prompt, ["yes", "no"], "yes", False)
    if response == "yes":
       try:
-         repos = rdiffWeb.rdw_spider_repos.findReposForUser(username, mysqlUserDb)
+         repos = rdiffWeb.rdw_spider_repos.findReposForUser(username, userDB)
       except OSError, error:
          print "Unable to search repository: " + str(error)
       else:
          print "Repository search complete."
+   userDB._executeQuery("END")
 
 def doMainSetup():
    try:
       import cherrypy
    except:
       print "Unable to load the CherryPy python module. This is most likely because it has not been installed. Please install this module and run the configuration again."
-      return
+      sys.exit(2)
    
    addConfigFileLine("ServerName=localhost")
    addConfigFileLine("ServerPort=8080")
 
-   print "Welcome to the rdiffWeb configuration script.\n"
-   backend = promptUser("""First, a configuration backend must be chosen.  There are two options: file and mysql.
-The file backend is simpler to set up, but is limited to a single user, and backup locations must be specified by hand (or by using this script).
-The mysql backend allows multiple users, automatic backup location spidering and storing of additional user data, but requires a MySQL server and the mysql-python package.
-Enter 1 for file, or 2 for mysql""", [1,2], 1, True)
-   print ""
-
-   if backend == 1:
-      fileSetup()
-   else:
-      mysqlSetup()
+   sqlSetup()
    print "Configuration complete!"
 
 def doAddUser():

Modified: trunk/rdiffWeb/db.py
===================================================================
--- trunk/rdiffWeb/db.py	2007-12-27 17:16:26 UTC (rev 194)
+++ trunk/rdiffWeb/db.py	2007-12-27 17:18:16 UTC (rev 195)
@@ -4,60 +4,6 @@
 
 class userDB:
    def getUserDBModule(self):
-      authModuleSetting = rdw_config.getConfigSetting("UserDB");
-      if authModuleSetting.lower() == "file":
-         import db_file
-         return db_file.fileUserDB()
-      if authModuleSetting.lower() == "mysql":
-         import db_mysql
-         return db_mysql.mysqlUserDB()
-      assert(False)
-      
-   def modificationsSupported(self):
-      return False
+      import db_sqlite
+      return db_sqlite.sqliteUserDB(rdw_config.getDatabasePath())
 
-   def areUserCredentialsValid(self, username, password):
-      raise NotImplementedError
-
-   def getUserRoot(self, username):
-      raise NotImplementedError
-
-   def getUserRepoPaths(self, username):
-      raise NotImplementedError
-
-   def getUserEmail(self, username):
-      raise NotImplementedError
-   
-   def useZipFormat(self, username):
-      raise NotImplementedError
-   
-   def getUserList(self):
-      raise NotImplementedError
-
-   def addUser(self, username):
-      raise NotImplementedError
-
-   def deleteUser(self, username):
-      raise NotImplementedError
-
-   def setUserInfo(self, username, userRoot, isAdmin):
-      raise NotImplementedError
-   
-   def setUserEmail(self, userEmail):
-      raise NotImplementedError
-
-   def setUserRepos(self, username, repos):
-      raise NotImplementedError
-
-   def setUserPassword(self, username, password):
-      raise NotImplementedError
-   
-   def setUseZipFormat(self, username, useZip):
-      raise NotImplementedError
-
-   def getUserRoot(self, username):
-      raise NotImplementedError
-
-   def userIsAdmin(self, username):
-      raise NotImplementedError
-

Added: trunk/rdiffWeb/db_sqlite.py
===================================================================
--- trunk/rdiffWeb/db_sqlite.py	2007-12-27 17:16:26 UTC (rev 194)
+++ trunk/rdiffWeb/db_sqlite.py	2007-12-27 17:18:16 UTC (rev 195)
@@ -0,0 +1,237 @@
+#!/usr/bin/python
+
+import rdw_config
+import db_sql
+
+"""We do no length validation for incoming parameters, since truncated values will
+at worst lead to slightly confusing results, but no security risks"""
+class sqliteUserDB():
+   def __init__(self, databaseFilePath):
+      import sqlite3
+      self._databaseFilePath = databaseFilePath
+      self.userRootCache = {}
+      self._connect()
+      self._migrateExistingData()
+
+   def modificationsSupported(self):
+      return True
+
+   def userExists(self, username):
+      results = self._executeQuery("SELECT Username FROM users WHERE Username = ?", (username,))
+      return len(results) == 1
+
+   def areUserCredentialsValid(self, username, password):
+      results = self._executeQuery("SELECT Username FROM users WHERE Username = ? AND Password = ?", (username, self._hashPassword(password)))
+      return len(results) == 1
+
+   def getUserRoot(self, username):
+      if not username in self.userRootCache:
+         self.userRootCache[username] = self._getUserField(username, "UserRoot")
+      return self.userRootCache[username]
+
+   def getUserRepoPaths(self, username):
+      if not self.userExists(username): return None
+      query = "SELECT RepoPath FROM repos WHERE UserID = %d" % self._getUserID(username)
+      repos = [ row[0] for row in self._executeQuery(query)]
+      repos.sort(lambda x, y: cmp(x.upper(), y.upper()))
+      return repos
+      
+   def getUserEmail(self, username):
+      if not self.userExists(username): return None
+      return self._getUserField(username, "userEmail")
+   
+   def useZipFormat(self, username):
+      if not self.userExists(username): return False
+      return bool(self._getUserField(username, "restoreFormat"))
+
+   def getUserList(self):
+      query = "SELECT UserName FROM users"
+      users = [x[0] for x in self._executeQuery(query)]
+      return users
+
+   def addUser(self, username):
+      if self.userExists(username): raise ValueError
+      query = "INSERT INTO users (Username) values (?)"
+      self._executeQuery(query, (username,))
+
+   def deleteUser(self, username):
+      if not self.userExists(username): raise ValueError
+      self._deleteUserRepos(username)
+      query = "DELETE FROM users WHERE Username = ?"
+      self._executeQuery(query, (username))
+
+   def setUserInfo(self, username, userRoot, isAdmin):
+      if not self.userExists(username): raise ValueError
+      if isAdmin:
+         adminInt = 1
+      else:
+         adminInt = 0
+      query = "UPDATE users SET UserRoot=?, IsAdmin="+str(adminInt)+" WHERE Username = ?"
+      self._executeQuery(query, (userRoot, username))
+      self.userRootCache[username] = userRoot # update cache
+
+   def setUserEmail(self, username, userEmail):
+      if not self.userExists(username): raise ValueError
+      self._setUserField(username, 'UserEmail', userEmail)
+      
+   def setUserRepos(self, username, repoPaths):
+      if not self.userExists(username): raise ValueError
+      userID = self._getUserID(username)
+      
+      # We don't want to just delete and recreate the repos, since that
+      # would lose notification information.      
+      existingRepos = self.getUserRepoPaths(username)      
+      reposToDelete = filter(lambda x: not x in repoPaths, existingRepos)
+      reposToAdd = filter(lambda x: not x in existingRepos, repoPaths)
+      
+      # delete any obsolete repos
+      for repo in reposToDelete:
+         query = "DELETE FROM repos WHERE UserID=? AND RepoPath=?"
+         self._executeQuery(query, (str(userID), repo))
+      
+      # add in new repos
+      query = "INSERT INTO repos (UserID, RepoPath) values (?, ?)"
+      repoPaths = [ [str(userID), repo] for repo in reposToAdd ]
+      cursor = self.sqlConnection.cursor()
+      cursor.executemany(query, repoPaths)
+
+   def setUserPassword(self, username, password):
+      if not self.userExists(username): raise ValueError
+      self._setUserField(username, 'Password', self._hashPassword(password))
+   
+   def setUseZipFormat(self, username, useZip):
+      if not self.userExists(username): raise ValueError
+      self._setUserField(username, 'RestoreFormat', bool(useZip))
+      
+   def setRepoMaxAge(self, username, repoPath, maxAge):
+      if not repoPath in self.getUserRepoPaths(username): raise ValueError
+      query = "UPDATE repos SET MaxAge=? WHERE RepoPath=? AND UserID = " + str(self._getUserID(username))
+      self._executeQuery(query, (maxAge, repoPath))
+      
+   def getRepoMaxAge(self, username, repoPath):
+      query = "SELECT MaxAge FROM repos WHERE RepoPath=? AND UserID = " + str(self._getUserID(username))
+      results = self._executeQuery(query, (repoPath,))
+      assert len(results) == 1
+      return int(results[0][0])
+      
+   def userIsAdmin(self, username):
+      return bool(self._getUserField(username, "IsAdmin"))
+
+   ########## Helper functions ###########   
+   def _deleteUserRepos(self, username):
+      if not self.userExists(username): raise ValueError
+      self._executeQuery("DELETE FROM repos WHERE UserID=%d" % self._getUserID(username))
+
+   def _getUserID(self, username):
+      assert self.userExists(username)
+      return self._getUserField(username, 'UserID')
+
+   def _getUserField(self, username, fieldName):
+      if not self.userExists(username): return None
+      query = "SELECT "+fieldName+" FROM users WHERE Username = ?"
+      results = self._executeQuery(query, (username,))
+      assert len(results) == 1
+      return results[0][0]
+      
+   def _setUserField(self, username, fieldName, value):
+      if not self.userExists(username): raise ValueError
+      if isinstance(value, bool):
+         if value:
+            valueStr = '1'
+         else:
+            valueStr = '0'
+      else:
+         valueStr = str(value)
+      query = 'UPDATE users SET '+fieldName+'=? WHERE Username=?'
+      self._executeQuery(query, (valueStr, username))
+
+   def _hashPassword(self, password):
+      import sha
+      hasher = sha.new()
+      hasher.update(password)
+      return hasher.hexdigest()
+   
+   def _executeQuery(self, query, args=()):
+      cursor = self.sqlConnection.cursor()
+      cursor.execute(query, args)
+      results = cursor.fetchall()
+      return results
+
+   def _connect(self):
+      import sqlite3
+      connectPath = self._databaseFilePath
+      if not connectPath:
+         connectPath = ":memory:"
+      self.sqlConnection = sqlite3.connect(connectPath)
+      self.sqlConnection.isolation_level = None
+      
+   def _getTables(self):
+      return [column[0] for column in self._executeQuery('select name from sqlite_master where type="table"')]
+
+   def _getCreateStatements(self):
+      return [
+"""create table users (
+UserID integer primary key autoincrement,
+Username varchar (50) unique NOT NULL,
+Password varchar (40) NOT NULL DEFAULT "",
+UserRoot varchar (255) NOT NULL DEFAULT "",
+IsAdmin tinyint NOT NULL DEFAULT FALSE,
+UserEmail varchar (255) NOT NULL DEFAULT "",
+RestoreFormat tinyint NOT NULL DEFAULT TRUE)""",
+"""create table repos (
+RepoID integer primary key autoincrement,
+UserID int(11) NOT NULL, 
+RepoPath varchar (255) NOT NULL,
+MaxAge tinyint NOT NULL DEFAULT 0)"""
+ ]
+
+   def _migrateExistingData(self):
+      """ If we don't have any data, we may be using a sqlite interface for the first time.
+      See if they have another database backend specified, and if they do, try to migrate the data."""
+      
+      if self._getTables(): return
+      
+      cursor = self.sqlConnection.cursor()
+      self.sqlConnection.execute("BEGIN TRANSACTION")
+      for statement in self._getCreateStatements():
+         cursor.execute(statement)
+
+      prevDBType = rdw_config.getConfigSetting("UserDB")
+      if prevDBType.lower() == "mysql":
+         print 'Converting database from mysql...'
+         import db_mysql
+         prevDB = db_mysql.mysqlUserDB()
+         users = prevDB._executeQuery("SELECT UserID, Username, Password, UserRoot, IsAdmin, UserEmail, RestoreFormat FROM users")
+         cursor.executemany("INSERT INTO users (UserID, Username, Password, UserRoot, IsAdmin, UserEmail, RestoreFormat) values (?, ?, ?, ?, ?, ?, ?)", users)
+         
+         repos = prevDB._executeQuery("SELECT RepoID, UserID, RepoPath, MaxAge FROM repos")
+         cursor.executemany("INSERT INTO repos (RepoID, UserID, RepoPath, MaxAge) values (?, ?, ?, ?)", repos)
+      elif prevDBType.lower() == "file":
+         print 'Converting database from file...'
+         import db_file
+         prevDB = db_file.fileUserDB()
+         username = rdw_config.getConfigSetting("username")
+         password = rdw_config.getConfigSetting("password")
+         self.addUser(username)
+         self.setUserPassword(username, password)
+         self.setUserInfo(username, prevDB.getUserRoot(username), True)
+         self.setUserRepos(username, prevDB.getUserRepoPaths(username))
+         
+      self.sqlConnection.execute("COMMIT TRANSACTION")
+
+
+class sqliteUserDBTest(db_sql.sqlUserDBTest):
+   """Unit tests for the sqliteUserDBTeste class"""
+   
+   def _getUserDBObject(self):
+      return sqliteUserDB(":memory:")
+   
+   def setUp(self):
+      super(sqliteUserDBTest, self).setUp()
+   
+   def tearDown(self):
+      pass
+
+   def testUserTruncation(self):
+      pass
+      
\ No newline at end of file


Property changes on: trunk/rdiffWeb/db_sqlite.py
___________________________________________________________________
Name: svn:executable
   + *

Modified: trunk/rdiffWeb/rdw_config.py
===================================================================
--- trunk/rdiffWeb/rdw_config.py	2007-12-27 17:16:26 UTC (rev 194)
+++ trunk/rdiffWeb/rdw_config.py	2007-12-27 17:18:16 UTC (rev 195)
@@ -9,6 +9,12 @@
       if os.access(settingsFile, os.F_OK):
          return settingsFile
    return ""
+   
+def getDatabasePath():
+   if os.access("/etc/rdiffweb/rdw.conf", os.F_OK):
+      return "/etc/rdiffweb/rdw.db"
+   return "rdw.db"
+   
 
 import os, re
 def getConfigSetting(settingName, settingsFile = None):



From commits at rdiffweb.org  Thu Dec 27 18:18:55 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Thu, 27 Dec 2007 18:18:55 +0100
Subject: [Rdiffweb-commits] r196 - trunk
Message-ID: <200712271718.lBRHItFx004094@sheep.berlios.de>

Author: joshn
Date: 2007-12-27 18:18:54 +0100 (Thu, 27 Dec 2007)
New Revision: 196

Modified:
   trunk/run_tests.py
Log:
Add tests for sqlite backend.

Modified: trunk/run_tests.py
===================================================================
--- trunk/run_tests.py	2007-12-27 17:18:16 UTC (rev 195)
+++ trunk/run_tests.py	2007-12-27 17:18:54 UTC (rev 196)
@@ -12,5 +12,6 @@
 from rdiffWeb.filter_authentication import rdwAuthenticationFilterTest
 from rdiffWeb.db_file import fileUserDataTest
 from rdiffWeb.rdw_config import configFileTest
+from rdiffWeb.db_sqlite import sqliteUserDBTest
 
 unittest.main()



From commits at rdiffweb.org  Fri Dec 28 03:12:50 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Fri, 28 Dec 2007 03:12:50 +0100
Subject: [Rdiffweb-commits] r197 - trunk/rdiffWeb
Message-ID: <200712280212.lBS2CobC003832@sheep.berlios.de>

Author: joshn
Date: 2007-12-28 03:12:48 +0100 (Fri, 28 Dec 2007)
New Revision: 197

Modified:
   trunk/rdiffWeb/rdw_config.py
Log:
Use classes for exceptions -- strings are now deprecated.

Modified: trunk/rdiffWeb/rdw_config.py
===================================================================
--- trunk/rdiffWeb/rdw_config.py	2007-12-27 17:18:54 UTC (rev 196)
+++ trunk/rdiffWeb/rdw_config.py	2007-12-28 02:12:48 UTC (rev 197)
@@ -1,7 +1,12 @@
 #!/usr/bin/python
 
-SettingsError = "Invalid configuration file syntax"
-ParameterError = "Invalid parameters"
+class SettingsError:
+   def __str__(self):
+      return "Invalid configuration file syntax"
+   
+class ParameterError:
+   def __str__(self):
+      return "Invalid parameters"
 
 def getConfigFile():
    settingsFiles = ["rdw.conf", "/etc/rdiffweb/rdw.conf" ] # TODO: there *has* to be a better way to get the /etc config file path...



From commits at rdiffweb.org  Fri Dec 28 03:15:06 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Fri, 28 Dec 2007 03:15:06 +0100
Subject: [Rdiffweb-commits] r198 - trunk/rdiffWeb
Message-ID: <200712280215.lBS2F61N004026@sheep.berlios.de>

Author: joshn
Date: 2007-12-28 03:15:03 +0100 (Fri, 28 Dec 2007)
New Revision: 198

Added:
   trunk/rdiffWeb/db_sql.py
Modified:
   trunk/rdiffWeb/db_mysql.py
   trunk/rdiffWeb/db_sqlite.py
Log:
Fix unit tests for sql-based user backends. Keep mysql backend around, in case sqlite doesn't cut it.


Modified: trunk/rdiffWeb/db_mysql.py
===================================================================
--- trunk/rdiffWeb/db_mysql.py	2007-12-28 02:12:48 UTC (rev 197)
+++ trunk/rdiffWeb/db_mysql.py	2007-12-28 02:15:03 UTC (rev 198)
@@ -1,6 +1,8 @@
 #!/usr/bin/python
 
+import db_sql
 import rdw_config
+import warnings
 
 """We do no length validation for incoming parameters, since truncated values will
 at worst lead to slightly confusing results, but no security risks"""
@@ -211,18 +213,24 @@
       columnNames = [column[0].lower() for column in self._executeQuery("describe users")]
       if not "restoreformat" in columnNames:
          self._executeQuery('alter table users add column RestoreFormat tinyint NOT NULL DEFAULT TRUE')
+         
+   def _getTables(self):
+      return [table[0].lower() for table in self._executeQuery("show tables")]
 
 
 ##################### Unit Tests #########################
 
 import unittest, os
-class mysqlUserDBTest(unittest.TestCase):
+class mysqlUserDBTest(db_sql.sqlUserDBTest):
    """Unit tests for the mysqlUserDBTest class"""
    configFileData = """sqlHost=localhost
                        sqlUsername=
                        sqlPassword=
                        sqlDatabase=test"""
    configFilePath = "/tmp/rdw_config.conf"
+   
+   def _getUserDBObject(self):
+      return mysqlUserDB(self.configFilePath)
 
    def setUp(self):
       file = open(self.configFilePath, "w")
@@ -232,15 +240,7 @@
       file = open(self.configFilePath, "w")
       file.write(self.configFileData)
       file.close()
-      userData = mysqlUserDB(self.configFilePath)
-      for statement in userData._getCreateStatements():
-         userData._executeQuery(statement)
 
-      userData.addUser("test")
-      userData.setUserInfo("test", "/data", False)
-      userData.setUserPassword("test", "user")
-      userData.setUserRepos("test", ["/data/bill", "/data/frank"])
-
    def tearDown(self):
       userData = mysqlUserDB(self.configFilePath)
       tableNames = [table[0].lower() for table in userData._executeQuery("show tables")]
@@ -251,14 +251,10 @@
       if (os.access(self.configFilePath, os.F_OK)):
          os.remove(self.configFilePath)
 
-   def testValidUser(self):
-      authModule = mysqlUserDB(self.configFilePath)
-      assert(authModule.userExists("test"))
-      assert(authModule.areUserCredentialsValid("test", "user"))
-
    def testUserTruncation(self):
+      warnings.filterwarnings('ignore', message='Data truncated')
       import MySQLdb
-      authModule = mysqlUserDB(self.configFilePath)
+      authModule = self._getUserDB()
       authModule.addUser("bill" * 1000)
       try:
          authModule.addUser("bill" * 1000 + "test")
@@ -266,55 +262,5 @@
          pass
       else:
          assert(false)
-
-   def testUserList(self):
-      authModule = mysqlUserDB(self.configFilePath)
-      assert(authModule.getUserList() == ["test"])
-
-   def testUserInfo(self):
-      authModule = mysqlUserDB(self.configFilePath)
-      assert(authModule.getUserRoot("test") == "/data")
-      assert(authModule.userIsAdmin("test") == False)
-
-   def testBadPassword(self):
-      authModule = mysqlUserDB(self.configFilePath)
-      assert(not authModule.areUserCredentialsValid("test", "user2")) # Basic test
-      assert(not authModule.areUserCredentialsValid("test", "User")) # password is case sensitive
-      assert(not authModule.areUserCredentialsValid("test", "use")) # Match entire password
-      assert(not authModule.areUserCredentialsValid("test", "")) # Match entire password
-
-   def testBadUser(self):
-      authModule = mysqlUserDB(self.configFilePath)
-      assert(not authModule.userExists("Test")) # username is case sensitive
-      assert(not authModule.userExists("tes")) # Match entire username
-
-   def testGoodUserDir(self):
-      userDataModule = mysqlUserDB(self.configFilePath)
-      assert(userDataModule.getUserRepoPaths("test") == ["/data/bill", "/data/frank"])
-      assert(userDataModule.getUserRoot("test") == "/data")
-
-   def testBadUserReturn(self):
-      userDataModule = mysqlUserDB(self.configFilePath)
-      assert(not userDataModule.getUserRepoPaths("test2")) # should return None if user doesn't exist
-      assert(not userDataModule.getUserRoot("")) # should return None if user doesn't exist
+      warnings.resetwarnings()
       
-   def testUserRepos(self):
-      userDataModule = mysqlUserDB(self.configFilePath)
-      userDataModule.setUserRepos("test", [])
-      userDataModule.setUserRepos("test", ["a", "b", "c"])
-      self.assertEquals(userDataModule.getUserRepoPaths("test"), ["a", "b", "c"])
-      # Make sure that repo max ages are initialized to 0
-      maxAges = [ userDataModule.getRepoMaxAge("test", x) for x in userDataModule.getUserRepoPaths("test") ]
-      self.assertEquals(maxAges, [0, 0, 0])
-      userDataModule.setRepoMaxAge("test", "b", 1)
-      self.assertEquals(userDataModule.getRepoMaxAge("test", "b"), 1)
-      userDataModule.setUserRepos("test", ["b", "c", "d"])
-      self.assertEquals(userDataModule.getRepoMaxAge("test", "b"), 1)
-      self.assertEquals(userDataModule.getUserRepoPaths("test"), ["b", "c", "d"])
-      
-   def testRestoreFormat(self):
-      userDataModule = mysqlUserDB(self.configFilePath)
-      assert(userDataModule.useZipFormat('test')) # Should default to using zip format
-      userDataModule.setUseZipFormat('test', False)
-      assert(not userDataModule.useZipFormat('test'))
-      

Added: trunk/rdiffWeb/db_sql.py
===================================================================
--- trunk/rdiffWeb/db_sql.py	2007-12-28 02:12:48 UTC (rev 197)
+++ trunk/rdiffWeb/db_sql.py	2007-12-28 02:15:03 UTC (rev 198)
@@ -0,0 +1,89 @@
+#!/usr/bin/python
+
+##################### Unit Tests #########################
+
+import unittest
+class sqlUserDBTest(unittest.TestCase):
+   """Generic unit tests for sql backends"""
+
+   def _getUserDB(self):
+      userData = self._getUserDBObject()
+      if not userData._getTables():
+         for statement in userData._getCreateStatements():
+            userData._executeQuery(statement)
+
+
+      userData.addUser("test")
+      userData.setUserInfo("test", "/data", False)
+      userData.setUserPassword("test", "user")
+      userData.setUserRepos("test", ["/data/bill", "/data/frank"])
+      return userData
+
+   def tearDown(self):
+      userData = self._getUserDB()
+      tableNames = userData._getTables()
+      print tableNames
+      if 'users' in tableNames:
+         userData._executeQuery("DROP TABLE users")
+      if 'repos' in tableNames:
+         userData._executeQuery("DROP TABLE repos")
+
+   def testValidUser(self):
+      authModule = self._getUserDB()
+      assert(authModule.userExists("test"))
+      assert(authModule.areUserCredentialsValid("test", "user"))
+
+   def testUserTruncation(self):
+      raise NotImplementedError
+
+   def testUserList(self):
+      authModule = self._getUserDB()
+      assert(authModule.getUserList() == ["test"])
+
+   def testUserInfo(self):
+      authModule = self._getUserDB()
+      assert(authModule.getUserRoot("test") == "/data")
+      assert(authModule.userIsAdmin("test") == False)
+
+   def testBadPassword(self):
+      authModule = self._getUserDB()
+      assert(not authModule.areUserCredentialsValid("test", "user2")) # Basic test
+      assert(not authModule.areUserCredentialsValid("test", "User")) # password is case sensitive
+      assert(not authModule.areUserCredentialsValid("test", "use")) # Match entire password
+      assert(not authModule.areUserCredentialsValid("test", "")) # Match entire password
+
+   def testBadUser(self):
+      authModule = self._getUserDB()
+      assert(not authModule.userExists("Test")) # username is case sensitive
+      assert(not authModule.userExists("tes")) # Match entire username
+
+   def testGoodUserDir(self):
+      userDataModule = self._getUserDB()
+      assert(userDataModule.getUserRepoPaths("test") == ["/data/bill", "/data/frank"])
+      assert(userDataModule.getUserRoot("test") == "/data")
+
+   def testBadUserReturn(self):
+      userDataModule = self._getUserDB()
+      assert(not userDataModule.getUserRepoPaths("test2")) # should return None if user doesn't exist
+      assert(not userDataModule.getUserRoot("")) # should return None if user doesn't exist
+      
+   def testUserRepos(self):
+      userDataModule = self._getUserDB()
+      userDataModule.setUserRepos("test", [])
+      userDataModule.setUserRepos("test", ["a", "b", "c"])
+      self.assertEquals(userDataModule.getUserRepoPaths("test"), ["a", "b", "c"])
+      # Make sure that repo max ages are initialized to 0
+      maxAges = [ userDataModule.getRepoMaxAge("test", x) for x in userDataModule.getUserRepoPaths("test") ]
+      self.assertEquals(maxAges, [0, 0, 0])
+      userDataModule.setRepoMaxAge("test", "b", 1)
+      self.assertEquals(userDataModule.getRepoMaxAge("test", "b"), 1)
+      userDataModule.setUserRepos("test", ["b", "c", "d"])
+      self.assertEquals(userDataModule.getRepoMaxAge("test", "b"), 1)
+      self.assertEquals(userDataModule.getUserRepoPaths("test"), ["b", "c", "d"])
+      
+   def testRestoreFormat(self):
+      userDataModule = self._getUserDB()
+      assert(userDataModule.useZipFormat('test')) # Should default to using zip format
+      userDataModule.setUseZipFormat('test', False)
+      assert(not userDataModule.useZipFormat('test'))
+      

Modified: trunk/rdiffWeb/db_sqlite.py
===================================================================
--- trunk/rdiffWeb/db_sqlite.py	2007-12-28 02:12:48 UTC (rev 197)
+++ trunk/rdiffWeb/db_sqlite.py	2007-12-28 02:15:03 UTC (rev 198)
@@ -6,9 +6,10 @@
 """We do no length validation for incoming parameters, since truncated values will
 at worst lead to slightly confusing results, but no security risks"""
 class sqliteUserDB():
-   def __init__(self, databaseFilePath):
+   def __init__(self, databaseFilePath, autoConvertDatabase=True):
       import sqlite3
       self._databaseFilePath = databaseFilePath
+      self._autoConvertDatabase = autoConvertDatabase
       self.userRootCache = {}
       self._connect()
       self._migrateExistingData()
@@ -196,27 +197,28 @@
       for statement in self._getCreateStatements():
          cursor.execute(statement)
 
-      prevDBType = rdw_config.getConfigSetting("UserDB")
-      if prevDBType.lower() == "mysql":
-         print 'Converting database from mysql...'
-         import db_mysql
-         prevDB = db_mysql.mysqlUserDB()
-         users = prevDB._executeQuery("SELECT UserID, Username, Password, UserRoot, IsAdmin, UserEmail, RestoreFormat FROM users")
-         cursor.executemany("INSERT INTO users (UserID, Username, Password, UserRoot, IsAdmin, UserEmail, RestoreFormat) values (?, ?, ?, ?, ?, ?, ?)", users)
+      if self._autoConvertDatabase:
+         prevDBType = rdw_config.getConfigSetting("UserDB")
+         if prevDBType.lower() == "mysql":
+            print 'Converting database from mysql...'
+            import db_mysql
+            prevDB = db_mysql.mysqlUserDB()
+            users = prevDB._executeQuery("SELECT UserID, Username, Password, UserRoot, IsAdmin, UserEmail, RestoreFormat FROM users")
+            cursor.executemany("INSERT INTO users (UserID, Username, Password, UserRoot, IsAdmin, UserEmail, RestoreFormat) values (?, ?, ?, ?, ?, ?, ?)", users)
+            
+            repos = prevDB._executeQuery("SELECT RepoID, UserID, RepoPath, MaxAge FROM repos")
+            cursor.executemany("INSERT INTO repos (RepoID, UserID, RepoPath, MaxAge) values (?, ?, ?, ?)", repos)
+         elif prevDBType.lower() == "file":
+            print 'Converting database from file...'
+            import db_file
+            prevDB = db_file.fileUserDB()
+            username = rdw_config.getConfigSetting("username")
+            password = rdw_config.getConfigSetting("password")
+            self.addUser(username)
+            self.setUserPassword(username, password)
+            self.setUserInfo(username, prevDB.getUserRoot(username), True)
+            self.setUserRepos(username, prevDB.getUserRepoPaths(username))
          
-         repos = prevDB._executeQuery("SELECT RepoID, UserID, RepoPath, MaxAge FROM repos")
-         cursor.executemany("INSERT INTO repos (RepoID, UserID, RepoPath, MaxAge) values (?, ?, ?, ?)", repos)
-      elif prevDBType.lower() == "file":
-         print 'Converting database from file...'
-         import db_file
-         prevDB = db_file.fileUserDB()
-         username = rdw_config.getConfigSetting("username")
-         password = rdw_config.getConfigSetting("password")
-         self.addUser(username)
-         self.setUserPassword(username, password)
-         self.setUserInfo(username, prevDB.getUserRoot(username), True)
-         self.setUserRepos(username, prevDB.getUserRepoPaths(username))
-         
       self.sqlConnection.execute("COMMIT TRANSACTION")
 
 
@@ -224,7 +226,7 @@
    """Unit tests for the sqliteUserDBTeste class"""
    
    def _getUserDBObject(self):
-      return sqliteUserDB(":memory:")
+      return sqliteUserDB(":memory:", autoConvertDatabase=False)
    
    def setUp(self):
       super(sqliteUserDBTest, self).setUp()



From commits at rdiffweb.org  Fri Dec 28 14:37:48 2007
From: commits at rdiffweb.org (commits at rdiffweb.org)
Date: Fri, 28 Dec 2007 14:37:48 +0100
Subject: [Rdiffweb-commits] r199 - trunk
Message-ID: <200712281337.lBSDbm2u015777@sheep.berlios.de>

Author: joshn
Date: 2007-12-28 14:37:46 +0100 (Fri, 28 Dec 2007)
New Revision: 199

Modified:
   trunk/rdiff-web
Log:
Fix error with spider threads

Modified: trunk/rdiff-web
===================================================================
--- trunk/rdiff-web	2007-12-28 02:15:03 UTC (rev 198)
+++ trunk/rdiff-web	2007-12-28 13:37:46 UTC (rev 199)
@@ -130,6 +130,6 @@
    
       rdiffWeb.rdw_spider_repos.startRepoSpiderThread(killEvent)
       rdiffWeb.email_notification.startEmailNotificationThread(killEvent)
-      cherrypy.server.on_stop_server_list.append(lambda: killEvent.set())
+      cherrypy.engine.on_stop_engine_list.append(lambda: killEvent.set())
 
    cherrypy.quickstart(root, config=page_settings)



